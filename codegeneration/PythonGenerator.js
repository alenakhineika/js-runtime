const ECMAScriptVisitor = require('../lib/ECMAScriptVisitor').ECMAScriptVisitor;

/**
 * This Visitor walks the tree generated by parsers and produces Python code
 *
 * @returns {object}
 */
function Visitor() {
  ECMAScriptVisitor.call(this);

  return this;
}

Visitor.prototype = Object.create(ECMAScriptVisitor.prototype);
Visitor.prototype.constructor = Visitor;
Visitor.prototype.start = Visitor.prototype.visitExpressionSequence;

/**
 * Visit children of current node
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitChildren = function(ctx) {
  let code = '';

  for (let i = 0; i < ctx.getChildCount(); i++) {
    code += this.visit(ctx.getChild(i));
  }

  return code.trim();
};

/**
 * Visit a leaf node and return a string
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitTerminal = function(ctx) {
  return ctx.getText();
};

/**
 * Visit Property Expression Assignment
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitPropertyExpressionAssignment = function(ctx) {
  // console.log(ctx.getText()); // Return the text of all tokens in the stream
  // console.log(ctx.getChildCount()); // How many children are there? If there is none, then this node represents a leaf node
  // console.log(ctx.getChild(0).getText()); // console.log(ctx.propertyName().getText()) Property 'x'
  // console.log(ctx.getChild(1).getText()); // ':'
  // console.log(ctx.getChild(2).getText()); // console.log(ctx.singleExpression().getText()) Value '1'

  const key = this.visit(ctx.propertyName()); // ctx.getChild(0)
  const value = this.visit(ctx.singleExpression()); // ctx.getChild(2)

  return `'${key}': ${value}`;
};

/**
 * Because python doesn't need `New`, we can skip the first child
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitNewExpression = function(ctx) {
  return this.visit(ctx.singleExpression());
};

/**
 * Visit Number Keyword
 *
 * @param {object} ctx
 * @returns {string}
 */
Visitor.prototype.visitNumberExpression = function(ctx) {
  const args = ctx.arguments();

  if (
    args.argumentList() === null || args.argumentList().getChildCount() !== 1
  ) {
    return 'Error: Number requires one argument';
  }

  const arg = args.argumentList().singleExpression()[0];
  const number = this.removeQuotes(this.visit(arg));

  return `int(${number})`;
};

/**
 * Remove quotes from string
 *
 * @param {String} str
 * @returns {String}
 */
Visitor.prototype.removeQuotes = function(str) {
  let newStr = str;

  if (
    (str.charAt(0) === '"' && str.charAt(str.length - 1) === '"') ||
    (str.charAt(0) === '\'' && str.charAt(str.length - 1) === '\'')
  ) {
    newStr = str.substr(1, str.length - 2);
  }

  return newStr;
};

/**
 * Visits an error node and return a user-defined result of the operation
 *
 * @param {object} ctx
 * @returns {String}
 */

Visitor.prototype.visitErrorNode = function(ctx) {
  return ctx.getText();
};

module.exports = Visitor;
